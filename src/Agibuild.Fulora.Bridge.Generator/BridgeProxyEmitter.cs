using System.Linq;
using System.Text;

namespace Agibuild.Fulora.Bridge.Generator;

/// <summary>
/// Emits a concrete proxy class for <see cref="BridgeDirection.Import"/> interfaces.
/// Each method calls <c>IWebViewRpcService.InvokeAsync</c> directly â€” no DispatchProxy.
/// </summary>
internal static class BridgeProxyEmitter
{
    public static string Emit(BridgeInterfaceModel model)
    {
        var sb = new StringBuilder();
        var className = $"{model.ServiceName}BridgeProxy";
        var ns = model.Namespace;

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Agibuild.Fulora;");
        sb.AppendLine();

        // Assembly attribute
        sb.AppendLine($"[assembly: global::Agibuild.Fulora.BridgeProxy(typeof({model.InterfaceFullName}), typeof({GetFullClassName(ns, className)}))]");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
        }

        var indent = string.IsNullOrEmpty(ns) ? "" : "    ";

        sb.AppendLine($"{indent}[global::System.CodeDom.Compiler.GeneratedCode(\"Agibuild.WebView.BridgeGenerator\", \"1.0.0\")]");
        sb.AppendLine($"{indent}internal sealed class {className} : {model.InterfaceFullName}");
        sb.AppendLine($"{indent}{{");

        // Constructor + field
        sb.AppendLine($"{indent}    private readonly global::Agibuild.Fulora.IWebViewRpcService _rpc;");
        sb.AppendLine();
        sb.AppendLine($"{indent}    public {className}(global::Agibuild.Fulora.IWebViewRpcService rpc)");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        _rpc = rpc ?? throw new global::System.ArgumentNullException(nameof(rpc));");
        sb.AppendLine($"{indent}    }}");

        // Methods
        foreach (var method in model.Methods)
        {
            sb.AppendLine();
            EmitMethod(sb, method, indent);
        }

        sb.AppendLine($"{indent}}}");

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void EmitMethod(StringBuilder sb, BridgeMethodModel method, string indent)
    {
        if (method.IsAsyncEnumerable)
        {
            EmitAsyncEnumerableMethod(sb, method, indent);
            return;
        }

        // Method signature
        var paramSignature = string.Join(", ", method.Parameters.Select(p =>
        {
            var sig = $"{p.TypeFullName} {p.Name}";
            if (p.HasDefaultValue)
                sig += $" = {p.DefaultValueLiteral ?? "default"}";
            return sig;
        }));

        sb.AppendLine($"{indent}    public async {method.ReturnTypeFullName} {method.Name}({paramSignature})");
        sb.AppendLine($"{indent}    {{");

        // Build named params object (exclude CancellationToken)
        var rpcParams = method.Parameters.Where(p => !p.IsCancellationToken).ToList();
        if (rpcParams.Count > 0)
        {
            sb.Append($"{indent}        var __params = new {{ ");
            sb.Append(string.Join(", ", rpcParams.Select(p => p.Name)));
            sb.AppendLine(" };");
        }
        else
        {
            sb.AppendLine($"{indent}        object? __params = null;");
        }

        // Invoke RPC with or without CancellationToken
        var ctParam = method.Parameters.FirstOrDefault(p => p.IsCancellationToken);
        var ctArg = ctParam is not null ? ctParam.Name : "";

        if (method.HasReturnValue && ctParam is not null)
        {
            sb.AppendLine($"{indent}        var __result = await _rpc.InvokeAsync<{method.InnerReturnTypeFullName}>(\"{method.RpcMethodName}\", __params, {ctArg}).ConfigureAwait(false);");
            sb.AppendLine($"{indent}        return __result!;");
        }
        else if (method.HasReturnValue)
        {
            sb.AppendLine($"{indent}        var __result = await _rpc.InvokeAsync<{method.InnerReturnTypeFullName}>(\"{method.RpcMethodName}\", __params).ConfigureAwait(false);");
            sb.AppendLine($"{indent}        return __result!;");
        }
        else if (ctParam is not null)
        {
            sb.AppendLine($"{indent}        await _rpc.InvokeAsync(\"{method.RpcMethodName}\", __params, {ctArg}).ConfigureAwait(false);");
        }
        else
        {
            sb.AppendLine($"{indent}        await _rpc.InvokeAsync(\"{method.RpcMethodName}\", __params).ConfigureAwait(false);");
        }

        sb.AppendLine($"{indent}    }}");
    }

    private static void EmitAsyncEnumerableMethod(StringBuilder sb, BridgeMethodModel method, string indent)
    {
        var paramSignature = string.Join(", ", method.Parameters.Select(p =>
        {
            var sig = $"{p.TypeFullName} {p.Name}";
            if (p.HasDefaultValue)
                sig += $" = {p.DefaultValueLiteral ?? "default"}";
            return sig;
        }));

        var innerType = method.AsyncEnumerableInnerType ?? "object";
        var ctParam = method.Parameters.FirstOrDefault(p => p.IsCancellationToken);

        sb.AppendLine($"{indent}    public async {method.ReturnTypeFullName} {method.Name}({paramSignature})");
        sb.AppendLine($"{indent}    {{");

        var rpcParams = method.Parameters.Where(p => !p.IsCancellationToken).ToList();
        if (rpcParams.Count > 0)
        {
            sb.Append($"{indent}        var __params = new {{ ");
            sb.Append(string.Join(", ", rpcParams.Select(p => p.Name)));
            sb.AppendLine(" };");
        }
        else
        {
            sb.AppendLine($"{indent}        object? __params = null;");
        }

        var ctArg = ctParam is not null ? $", {ctParam.Name}" : "";

        sb.AppendLine($"{indent}        var __initResult = await _rpc.InvokeAsync<global::System.Text.Json.JsonElement>(\"{method.RpcMethodName}\", __params{ctArg}).ConfigureAwait(false);");
        sb.AppendLine($"{indent}        var __token = __initResult.GetProperty(\"token\").GetString()!;");
        sb.AppendLine($"{indent}        var __finished = __initResult.TryGetProperty(\"finished\", out var __fin) && __fin.GetBoolean();");
        sb.AppendLine();
        sb.AppendLine($"{indent}        if (__initResult.TryGetProperty(\"values\", out var __prefetch))");
        sb.AppendLine($"{indent}        {{");
        sb.AppendLine($"{indent}            foreach (var __v in __prefetch.EnumerateArray())");
        sb.AppendLine($"{indent}            {{");
        sb.AppendLine($"{indent}                yield return __v.Deserialize<{innerType}>()!;");
        sb.AppendLine($"{indent}            }}");
        sb.AppendLine($"{indent}        }}");
        sb.AppendLine();
        sb.AppendLine($"{indent}        if (__finished) yield break;");
        sb.AppendLine();
        sb.AppendLine($"{indent}        while (true)");
        sb.AppendLine($"{indent}        {{");
        sb.AppendLine($"{indent}            var __next = await _rpc.InvokeAsync<global::System.Text.Json.JsonElement>(\"$/enumerator/next/\" + __token{ctArg}).ConfigureAwait(false);");
        sb.AppendLine($"{indent}            var __done = __next.TryGetProperty(\"finished\", out var __f) && __f.GetBoolean();");
        sb.AppendLine($"{indent}            if (__next.TryGetProperty(\"values\", out var __vals))");
        sb.AppendLine($"{indent}            {{");
        sb.AppendLine($"{indent}                foreach (var __v in __vals.EnumerateArray())");
        sb.AppendLine($"{indent}                {{");
        sb.AppendLine($"{indent}                    yield return __v.Deserialize<{innerType}>()!;");
        sb.AppendLine($"{indent}                }}");
        sb.AppendLine($"{indent}            }}");
        sb.AppendLine($"{indent}            if (__done) yield break;");
        sb.AppendLine($"{indent}        }}");
        sb.AppendLine($"{indent}    }}");
    }

    private static string GetFullClassName(string ns, string className)
    {
        return string.IsNullOrEmpty(ns) ? $"global::{className}" : $"global::{ns}.{className}";
    }
}
