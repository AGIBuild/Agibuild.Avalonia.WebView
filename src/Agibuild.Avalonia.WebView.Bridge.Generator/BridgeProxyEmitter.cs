using System.Linq;
using System.Text;

namespace Agibuild.Avalonia.WebView.Bridge.Generator;

/// <summary>
/// Emits a concrete proxy class for <see cref="BridgeDirection.Import"/> interfaces.
/// Each method calls <c>IWebViewRpcService.InvokeAsync</c> directly — no DispatchProxy.
/// </summary>
internal static class BridgeProxyEmitter
{
    public static string Emit(BridgeInterfaceModel model)
    {
        var sb = new StringBuilder();
        var className = $"{model.ServiceName}BridgeProxy";
        var ns = model.Namespace;

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Text.Json;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Agibuild.Avalonia.WebView;");
        sb.AppendLine();

        // Assembly attribute
        sb.AppendLine($"[assembly: global::Agibuild.Avalonia.WebView.BridgeProxy(typeof({model.InterfaceFullName}), typeof({GetFullClassName(ns, className)}))]");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
        }

        var indent = string.IsNullOrEmpty(ns) ? "" : "    ";

        sb.AppendLine($"{indent}[global::System.CodeDom.Compiler.GeneratedCode(\"Agibuild.WebView.BridgeGenerator\", \"1.0.0\")]");
        sb.AppendLine($"{indent}internal sealed class {className} : {model.InterfaceFullName}");
        sb.AppendLine($"{indent}{{");

        // Constructor + field
        sb.AppendLine($"{indent}    private readonly global::Agibuild.Avalonia.WebView.IWebViewRpcService _rpc;");
        sb.AppendLine();
        sb.AppendLine($"{indent}    public {className}(global::Agibuild.Avalonia.WebView.IWebViewRpcService rpc)");
        sb.AppendLine($"{indent}    {{");
        sb.AppendLine($"{indent}        _rpc = rpc ?? throw new global::System.ArgumentNullException(nameof(rpc));");
        sb.AppendLine($"{indent}    }}");

        // Methods
        foreach (var method in model.Methods)
        {
            sb.AppendLine();
            EmitMethod(sb, method, indent);
        }

        sb.AppendLine($"{indent}}}");

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static void EmitMethod(StringBuilder sb, BridgeMethodModel method, string indent)
    {
        // Method signature
        var paramSignature = string.Join(", ", method.Parameters.Select(p =>
        {
            var sig = $"{p.TypeFullName} {p.Name}";
            if (p.HasDefaultValue)
                sig += $" = {p.DefaultValueLiteral ?? "default"}";
            return sig;
        }));

        sb.AppendLine($"{indent}    public async {method.ReturnTypeFullName} {method.Name}({paramSignature})");
        sb.AppendLine($"{indent}    {{");

        // Build named params object
        if (method.Parameters.Length > 0)
        {
            sb.Append($"{indent}        var __params = new {{ ");
            sb.Append(string.Join(", ", method.Parameters.Select(p => p.Name)));
            sb.AppendLine(" };");
        }
        else
        {
            sb.AppendLine($"{indent}        object? __params = null;");
        }

        // Invoke RPC
        if (method.HasReturnValue)
        {
            // InvokeAsync<T> returns T? — for value types we need explicit cast, for reference types use ?? default!
            sb.AppendLine($"{indent}        var __result = await _rpc.InvokeAsync<{method.InnerReturnTypeFullName}>(\"{method.RpcMethodName}\", __params).ConfigureAwait(false);");
            sb.AppendLine($"{indent}        return __result!;");
        }
        else
        {
            sb.AppendLine($"{indent}        await _rpc.InvokeAsync(\"{method.RpcMethodName}\", __params).ConfigureAwait(false);");
        }

        sb.AppendLine($"{indent}    }}");
    }

    private static string GetFullClassName(string ns, string className)
    {
        return string.IsNullOrEmpty(ns) ? $"global::{className}" : $"global::{ns}.{className}";
    }
}
