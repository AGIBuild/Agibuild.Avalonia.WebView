using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Agibuild.Avalonia.WebView.Bridge.Generator;

/// <summary>
/// Emits TypeScript declaration files (.d.ts) as string constants embedded in a generated C# class.
/// The MSBuild target or runtime can extract these constants and write them to disk.
/// </summary>
internal static class TypeScriptEmitter
{
    public static string EmitDeclarations(IReadOnlyList<BridgeInterfaceModel> exports, IReadOnlyList<BridgeInterfaceModel> imports)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Collect namespace from first model
        var ns = exports.Count > 0 ? exports[0].Namespace
               : imports.Count > 0 ? imports[0].Namespace
               : "";

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
        }

        var indent = string.IsNullOrEmpty(ns) ? "" : "    ";

        sb.AppendLine($"{indent}/// <summary>");
        sb.AppendLine($"{indent}/// Contains auto-generated TypeScript declarations for bridge interfaces.");
        sb.AppendLine($"{indent}/// Use <c>BridgeTypeScriptDeclarations.All</c> to get the full .d.ts content.");
        sb.AppendLine($"{indent}/// </summary>");
        sb.AppendLine($"{indent}[global::System.CodeDom.Compiler.GeneratedCode(\"Agibuild.WebView.BridgeGenerator\", \"1.0.0\")]");
        sb.AppendLine($"{indent}internal static class BridgeTypeScriptDeclarations");
        sb.AppendLine($"{indent}{{");

        // Per-service declarations
        foreach (var model in exports)
        {
            var tsContent = GenerateTsInterface(model, isExport: true);
            sb.AppendLine($"{indent}    /// <summary>TypeScript declaration for {model.InterfaceName}.</summary>");
            sb.AppendLine($"{indent}    public const string {model.ServiceName} = @\"{EscapeVerbatim(tsContent)}\";");
            sb.AppendLine();
        }

        foreach (var model in imports)
        {
            var tsContent = GenerateTsInterface(model, isExport: false);
            sb.AppendLine($"{indent}    /// <summary>TypeScript declaration for {model.InterfaceName}.</summary>");
            sb.AppendLine($"{indent}    public const string {model.ServiceName} = @\"{EscapeVerbatim(tsContent)}\";");
            sb.AppendLine();
        }

        // Combined "All" declaration
        var allTs = new StringBuilder();
        allTs.AppendLine("// Auto-generated by Agibuild.Avalonia.WebView.Bridge.Generator");
        allTs.AppendLine("// Do not edit manually.");
        allTs.AppendLine();

        foreach (var model in exports)
            allTs.AppendLine(GenerateTsInterface(model, isExport: true));
        foreach (var model in imports)
            allTs.AppendLine(GenerateTsInterface(model, isExport: false));

        // Bridge global declaration
        allTs.AppendLine("declare global {");
        allTs.AppendLine("  interface Window {");
        allTs.AppendLine("    agWebView: {");
        allTs.AppendLine("      bridge: {");
        foreach (var model in exports)
        {
            allTs.AppendLine($"        {ModelExtractor.ToCamelCase(model.ServiceName)}: {model.ServiceName};");
        }
        allTs.AppendLine("      };");
        allTs.AppendLine("      rpc: {");
        allTs.AppendLine("        invoke(method: string, params?: unknown): Promise<unknown>;");
        allTs.AppendLine("        handle(method: string, handler: (params: unknown) => unknown | Promise<unknown>): void;");
        allTs.AppendLine("      };");
        allTs.AppendLine("    };");
        allTs.AppendLine("  }");
        allTs.AppendLine("}");

        sb.AppendLine($"{indent}    /// <summary>Complete .d.ts file content for all bridge interfaces.</summary>");
        sb.AppendLine($"{indent}    public const string All = @\"{EscapeVerbatim(allTs.ToString())}\";");

        sb.AppendLine($"{indent}}}");

        if (!string.IsNullOrEmpty(ns))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    private static string GenerateTsInterface(BridgeInterfaceModel model, bool isExport)
    {
        var sb = new StringBuilder();
        var keyword = isExport ? "export" : "export";

        sb.AppendLine($"/** {(isExport ? "C# service exposed to JS" : "JS service callable from C#")} */");
        sb.AppendLine($"{keyword} interface {model.ServiceName} {{");

        foreach (var method in model.Methods)
        {
            var tsParams = string.Join(", ", method.Parameters.Select(p =>
            {
                var tsType = CSharpTypeToTypeScript(p.TypeFullName);
                var optional = p.IsNullable || p.HasDefaultValue ? "?" : "";
                return $"{p.CamelCaseName}{optional}: {tsType}";
            }));

            var tsReturn = method.HasReturnValue
                ? $"Promise<{CSharpTypeToTypeScript(method.InnerReturnTypeFullName ?? "void")}>"
                : "Promise<void>";

            sb.AppendLine($"  {method.CamelCaseName}({tsParams}): {tsReturn};");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    internal static string CSharpTypeToTypeScript(string csharpType)
    {
        // Strip nullable annotation
        var type = csharpType.TrimEnd('?');

        // Primitives
        if (type is "string" or "System.String") return "string";
        if (type is "int" or "System.Int32" or "long" or "System.Int64"
            or "short" or "System.Int16" or "float" or "System.Single"
            or "double" or "System.Double" or "decimal" or "System.Decimal"
            or "byte" or "System.Byte") return "number";
        if (type is "bool" or "System.Boolean") return "boolean";
        if (type is "void" or "System.Void") return "void";
        if (type is "System.DateTime" or "System.DateTimeOffset") return "string"; // ISO 8601
        if (type is "System.Guid") return "string";
        if (type is "byte[]" or "System.Byte[]") return "string"; // base64

        // Collections
        if (type.StartsWith("System.Collections.Generic.List<") || type.StartsWith("System.Collections.Generic.IList<")
            || type.StartsWith("System.Collections.Generic.IReadOnlyList<") || type.StartsWith("System.Collections.Generic.IEnumerable<"))
        {
            var inner = ExtractGenericArg(type);
            return $"{CSharpTypeToTypeScript(inner)}[]";
        }

        if (type.StartsWith("System.Collections.Generic.Dictionary<") || type.StartsWith("System.Collections.Generic.IDictionary<"))
        {
            var args = ExtractGenericArgs(type);
            if (args.Count >= 2)
                return $"Record<{CSharpTypeToTypeScript(args[0])}, {CSharpTypeToTypeScript(args[1])}>";
        }

        // Fallback: use the short type name
        var lastDot = type.LastIndexOf('.');
        return lastDot >= 0 ? type.Substring(lastDot + 1) : type;
    }

    private static string ExtractGenericArg(string type)
    {
        var start = type.IndexOf('<');
        var end = type.LastIndexOf('>');
        if (start >= 0 && end > start)
            return type.Substring(start + 1, end - start - 1).Trim();
        return "unknown";
    }

    private static List<string> ExtractGenericArgs(string type)
    {
        var inner = ExtractGenericArg(type);
        // Simple split on comma (doesn't handle nested generics, but sufficient for V1)
        return inner.Split(',').Select(s => s.Trim()).ToList();
    }

    private static string EscapeVerbatim(string s) => s.Replace("\"", "\"\"");
}
