# bridge-source-generator — Design

## Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│  Consumer Assembly (e.g. MyApp)                                      │
│                                                                      │
│  [JsExport] interface IAppService { ... }                            │
│  [JsImport] interface IUiController { ... }                          │
│                                                                      │
│  // SG generates (at compile time):                                  │
│  ├─ AppServiceBridgeRegistration : IBridgeServiceRegistration<T>     │
│  ├─ UiControllerBridgeProxy : IUiController                         │
│  ├─ BridgeJsonContext : JsonSerializerContext                        │
│  └─ [assembly: BridgeRegistration(...)]                              │
│     [assembly: BridgeProxy(...)]                                     │
└─────────────────────────┬───────────────────────────────────────────┘
                          │ discovered via assembly attributes
┌─────────────────────────▼───────────────────────────────────────────┐
│  RuntimeBridgeService (Runtime)                                      │
│  ├─ Expose<T>(): finds IBridgeServiceRegistration<T> → uses it       │
│  │   fallback: reflection (existing code)                            │
│  ├─ GetProxy<T>(): finds generated proxy → instantiates it           │
│  │   fallback: DispatchProxy (existing code)                         │
│  └─ JS stub injection unchanged                                     │
└─────────────────────────────────────────────────────────────────────┘
```

## Registration Discovery Pattern

### Core contracts (new in Core assembly)

```csharp
/// <summary>Implemented by source-generated registration classes.</summary>
public interface IBridgeServiceRegistration<T> where T : class
{
    string ServiceName { get; }
    IReadOnlyList<string> MethodNames { get; }
    void RegisterHandlers(IWebViewRpcService rpc, T implementation);
    void UnregisterHandlers(IWebViewRpcService rpc);
    string GetJsStub();
}

/// <summary>Assembly-level attribute linking interface → registration type.</summary>
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
public sealed class BridgeRegistrationAttribute : Attribute
{
    public Type InterfaceType { get; }
    public Type RegistrationType { get; }
    public BridgeRegistrationAttribute(Type interfaceType, Type registrationType)
    { InterfaceType = interfaceType; RegistrationType = registrationType; }
}

/// <summary>Assembly-level attribute linking interface → proxy type.</summary>
[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
public sealed class BridgeProxyAttribute : Attribute
{
    public Type InterfaceType { get; }
    public Type ProxyType { get; }
    public BridgeProxyAttribute(Type interfaceType, Type proxyType)
    { InterfaceType = interfaceType; ProxyType = proxyType; }
}
```

### Generated code example (for `[JsExport] IAppService`)

```csharp
// Auto-generated by Agibuild.Fulora.Bridge.Generator
[assembly: BridgeRegistration(typeof(IAppService), typeof(AppServiceBridgeRegistration))]

internal sealed class AppServiceBridgeRegistration : IBridgeServiceRegistration<IAppService>
{
    public string ServiceName => "AppService";
    public IReadOnlyList<string> MethodNames => new[] { "AppService.getCurrentUser", "AppService.saveSettings", "AppService.searchItems" };

    public void RegisterHandlers(IWebViewRpcService rpc, IAppService impl)
    {
        rpc.Handle("AppService.getCurrentUser", async args =>
        {
            var result = await impl.GetCurrentUser();
            return result;
        });
        rpc.Handle("AppService.saveSettings", async args =>
        {
            var settings = args?.Deserialize<AppSettings>(BridgeJsonContext.Default.AppSettings)
                ?? throw new ArgumentNullException("settings");
            await impl.SaveSettings(settings);
            return null;
        });
        // ... searchItems ...
    }

    public void UnregisterHandlers(IWebViewRpcService rpc)
    {
        rpc.RemoveHandler("AppService.getCurrentUser");
        rpc.RemoveHandler("AppService.saveSettings");
        rpc.RemoveHandler("AppService.searchItems");
    }

    public string GetJsStub() => """
        (function() {
            if (!window.agWebView) window.agWebView = {};
            if (!window.agWebView.bridge) window.agWebView.bridge = {};
            window.agWebView.bridge.AppService = {
                getCurrentUser: function(params) { return window.agWebView.rpc.invoke('AppService.getCurrentUser', params); },
                saveSettings: function(params) { return window.agWebView.rpc.invoke('AppService.saveSettings', params); },
                searchItems: function(params) { return window.agWebView.rpc.invoke('AppService.searchItems', params); }
            };
        })();
        """;
}
```

### Generated code example (for `[JsImport] IUiController`)

```csharp
[assembly: BridgeProxy(typeof(IUiController), typeof(UiControllerBridgeProxy))]

internal sealed class UiControllerBridgeProxy : IUiController
{
    private readonly IWebViewRpcService _rpc;
    public UiControllerBridgeProxy(IWebViewRpcService rpc) => _rpc = rpc;

    public async Task ShowNotification(string message, string? title = null)
    {
        await _rpc.InvokeAsync("UiController.showNotification", new { message, title });
    }

    public async Task<bool> ConfirmDialog(string prompt)
    {
        return await _rpc.InvokeAsync<bool>("UiController.confirmDialog", new { prompt });
    }

    public async Task UpdateTheme(ThemeOptions options)
    {
        await _rpc.InvokeAsync("UiController.updateTheme", new { options });
    }
}
```

## Source Generator Project

- **Project**: `Agibuild.Fulora.Bridge.Generator`
- **Target**: `netstandard2.0` (Roslyn requirement)
- **References**: `Microsoft.CodeAnalysis.CSharp` (analyzer-only)
- **Entry point**: `WebViewBridgeGenerator : IIncrementalGenerator`
- **Uses**: `ForAttributeWithMetadataName` for efficient attribute detection

### Generator Pipeline

```
SyntaxProvider.ForAttributeWithMetadataName("JsExportAttribute")
  → Extract interface model (name, methods, params, return types)
  → BridgeHostEmitter.Emit() → registration class source
  → JsStubEmitter.Emit() → JS stub string constant
  → Assembly attribute

SyntaxProvider.ForAttributeWithMetadataName("JsImportAttribute")
  → Extract interface model
  → BridgeProxyEmitter.Emit() → proxy class source
  → Assembly attribute

Combine all type models
  → BridgeJsonContextEmitter.Emit() → STJ JsonSerializerContext
```

### TypeMapper

Maps C# types to JSON deserialization calls:

| C# Type | Generated Deserialize Call |
|---------|--------------------------|
| `string` | `args?.GetString()` |
| `int` | `args?.GetInt32()` |
| `bool` | `args?.GetBoolean()` |
| `double` | `args?.GetDouble()` |
| `T` (complex) | `args?.Deserialize<T>(BridgeJsonContext.Default.T)` |
| `List<T>` | `args?.Deserialize<List<T>>(...)` |
| `T?` (nullable) | null-safe wrapper |

## RuntimeBridgeService Integration

```csharp
// In Expose<T>():
var registration = FindGeneratedRegistration<T>();
if (registration is not null)
{
    // Use generated code (AOT safe, no reflection)
    registration.RegisterHandlers(_rpc, implementation);
    _ = _invokeScript(registration.GetJsStub());
}
else
{
    // Fallback to reflection (existing code)
    ReflectionExposeInternal(implementation);
}
```

## Testing Strategy

1. **Generator unit tests** — verify generated source text for known input interfaces
2. **Compile-and-run tests** — compile generated code in memory, verify it works end-to-end
3. **Integration with existing CT** — add tests that verify generated registrations are discovered by RuntimeBridgeService
